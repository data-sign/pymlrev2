## 8.5 감성분석
### 8.5.1 개요 
- 문서의 주관적인 감성/의견/감정/기분 등을 파악하기 위해 단어와 문맥 기반으로 감성 수치를 계산하여 긍정 감성지수와 부정 감성 지수를 합산해 긍/부정 결정하는 방법
- 소셜 미디어, 여론조사, 온라인 리뷰 등에 활용됨
- 지도학습 : 학습 데이터와 타깃 레이블 값 기반 감성 분석 학습 후 다른 데이터의 감성 예측하는 방법으로 일반적인 텍스트 분류와 동일
- 비지도학습 : Lexicon 이라는 감성 어휘 사전을 이용해 문서의 긍/부정 감성 여부 판단 

### 지도학습 기반 감성 분석 - IMDB 영화평
- 텍스트 기반 이진 분류와 동일
- IMDB 영화 사이트 영화평을 이용해 감성 분석 실습 
- 데이터 : https://www.kaggle.com/c/word2vec-nlp-tutorial/data
    - id : 각 데이터의 id
    - sentiment : 영화평의 sentiment 결과 값(1:긍정, 0:부정)
    - review : 영화평의 텍스트
```python
import pandas as pd

review_df = pd.read_csv('./labeledTrainData.tsv', header=0, sep="\t", quoting=3)
review_df.head(3)

## 전처리 : <br/> 태그 없애기, 영어문자열 아니면 공백으로 변환
import re

# <br> html 태그는 replace 함수로 공백으로 변환
review_df['review'] = review_df['review'].str.replace('<br />',' ')

# 파이썬의 정규 표현식 모듈인 re를 이용하여 영어 문자열이 아닌 문자는 모두 공백으로 변환 
review_df['review'] = review_df['review'].apply( lambda x : re.sub("[^a-zA-Z]", " ", x) )

from sklearn.model_selection import train_test_split

class_df = review_df['sentiment']
feature_df = review_df.drop(['id','sentiment'], axis=1, inplace=False)

X_train, X_test, y_train, y_test= train_test_split(feature_df, class_df, test_size=0.3, random_state=156)

X_train.shape, X_test.shape

from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, roc_auc_score

# 스톱 워드는 English, filtering, ngram은 (1,2)로 설정해 CountVectorization수행. 
# LogisticRegression의 C는 10으로 설정. 
pipeline = Pipeline([
    ('cnt_vect', CountVectorizer(stop_words='english', ngram_range=(1,2) )),
    ('lr_clf', LogisticRegression(solver='liblinear', C=10))])

# Pipeline 객체를 이용하여 fit(), predict()로 학습/예측 수행. predict_proba()는 roc_auc때문에 수행.  
pipeline.fit(X_train['review'], y_train)
pred = pipeline.predict(X_test['review'])
pred_probs = pipeline.predict_proba(X_test['review'])[:,1]

print('예측 정확도는 {0:.4f}, ROC-AUC는 {1:.4f}'.format(accuracy_score(y_test ,pred),
                                         roc_auc_score(y_test, pred_probs)))

# 스톱 워드는 english, filtering, ngram은 (1,2)로 설정해 TF-IDF 벡터화 수행. 
# LogisticRegression의 C는 10으로 설정. 
pipeline = Pipeline([
    ('tfidf_vect', TfidfVectorizer(stop_words='english', ngram_range=(1,2) )),
    ('lr_clf', LogisticRegression(solver='liblinear', C=10))])

pipeline.fit(X_train['review'], y_train)
pred = pipeline.predict(X_test['review'])
pred_probs = pipeline.predict_proba(X_test['review'])[:,1]

print('예측 정확도는 {0:.4f}, ROC-AUC는 {1:.4f}'.format(accuracy_score(y_test ,pred),
                                         roc_auc_score(y_test, pred_probs)))                                         

```

### 비지도학습 기반 감성 분석
- 긍정/부정 정도를 수치화한 감성 지수가 담긴 어휘 사전 'Lexicon' 이용
- 단어의 위치나 주변 단어, 문맥, POS(Part of Speech) 참고해 결정됨
- NLTK의 WordNet : 시맨틱 분석(문맥상 의미)을 제공하는 어휘 사전
    - 동일한 단어나 문장이라도 문맥에 따라 다르게 해석됨. 
    - e.g. present : 선물, 현재 
    - 다양한 상황에서 다르게 사용되는 어휘의 시맨틱 정보를 제공하고, 각가의 품사로 구성된 개별 단어를 Synset(Sets of cognitive synonyms) 개념 이용해 표현 
- 감성 사전 
    - NLTK : Lexicon 모듈 및 많은 서브 모듈이 포함된 패키지지만 예측성능이 좋지 않아 실제 적용하지 않음. 
    - SentiWordNet : NLTK 패키지와 유사하게 감성 단어 전용으로 Wordnet 구현. WordNet의 Synset 별로 3가지 감성 점수 할당(긍정 감성 지수, 부정 감성 지수, 객관성 지수). 문장별 긍부정 지수를 합산하여 최종 감성 지수 계산하여 최종 긍/부정 결정 
    - VADER : 주로 소셜 미디어 텍스트에 대한 감성 분석 제공을 위한 패키지. 뛰어난 감성 분석 결과와 빠른 수행 시간으로 대용량 텍스트에 활용
    - Pattern : 예측 성능 좋으나 파이썬 3버전 호환 안됨. 

#### SentiWordNet 이용한 감성 분석 
##### WordNet Synset
- synsets(word) : WordNet에 등재된 모든 synset 객체 반환
- 리스트형태로 반환되며, 의미와 품사를 알려주는 POS 태그, 인덱스로 구성됨 
- synset.lexname() : 품사 
- synset.definition() : 정의
- synset.lemma_names() : 부명제 
- 어휘 간 유사도 계산 : path_similarity() 

```python
import nltk
nltk.download('all')

from nltk.corpus import wordnet as wn

term = 'present'

# 'present'라는 단어로 wordnet의 synsets 생성. 
synsets = wn.synsets(term)
print('synsets() 반환 type :', type(synsets))
print('synsets() 반환 값 갯수:', len(synsets))
print('synsets() 반환 값 :', synsets)

for synset in synsets :
    print('##### Synset name : ', synset.name(),'#####')
    print('POS :',synset.lexname())
    print('Definition:',synset.definition())
    print('Lemmas:',synset.lemma_names())

# synset 객체를 단어별로 생성합니다. 
tree = wn.synset('tree.n.01')
lion = wn.synset('lion.n.01')
tiger = wn.synset('tiger.n.02')
cat = wn.synset('cat.n.01')
dog = wn.synset('dog.n.01')

entities = [tree , lion , tiger , cat , dog]
similarities = []
entity_names = [ entity.name().split('.')[0] for entity in entities]

# 단어별 synset 들을 iteration 하면서 다른 단어들의 synset과 유사도를 측정합니다. 
for entity in entities:
    similarity = [ round(entity.path_similarity(compared_entity), 2)  for compared_entity in entities ]
    similarities.append(similarity)
    
# 개별 단어별 synset과 다른 단어의 synset과의 유사도를 DataFrame형태로 저장합니다.  
similarity_df = pd.DataFrame(similarities , columns=entity_names,index=entity_names)
similarity_df  

```

##### SentiWordNet SentiSynset
- senti_synsets(word) : sentisynset 객체를 리스트 형태로 반환 
- senti_synsets.pos_score() : 긍정감성 지수 
- senti_synsets.neg_score() : 부정감성 지수
- senti_synsets.obj_score() : 객관성 지수 
- 감성적이지 않은 단어는 객관성 지수 1 

```python
import nltk
from nltk.corpus import sentiwordnet as swn

senti_synsets = list(swn.senti_synsets('slow'))
print('senti_synsets() 반환 type :', type(senti_synsets))
print('senti_synsets() 반환 값 갯수:', len(senti_synsets))
print('senti_synsets() 반환 값 :', senti_synsets)

import nltk
from nltk.corpus import sentiwordnet as swn

father = swn.senti_synset('father.n.01')
print('father 긍정감성 지수: ', father.pos_score())
print('father 부정감성 지수: ', father.neg_score())
print('father 객관성 지수: ', father.obj_score())
print('\n')
fabulous = swn.senti_synset('fabulous.a.01')
print('fabulous 긍정감성 지수: ',fabulous .pos_score())
print('fabulous 부정감성 지수: ',fabulous .neg_score())

```

##### SentiWordNet 이용해 영화 감상평 감성 분석 
1. 문서를 문장 단위로 분해 
2. 문장을 단어 단위로 토큰화하고 어근 추출과 품사 태깅 (WordNet 이용)
3. 품사 태깅된 단어 기반 synset 객체와 senti_synset 객체 생성
4. senti_synset 긍/부정 지수 구한 후, 모두 합산해 임계치 넘으면 긍정 아니면 부정 결정 

```python
from nltk.corpus import wordnet as wn

# 간단한 NTLK PennTreebank Tag를 기반으로 WordNet기반의 품사 Tag로 변환
def penn_to_wn(tag):
    if tag.startswith('J'):
        return wn.ADJ
    elif tag.startswith('N'):
        return wn.NOUN
    elif tag.startswith('R'):
        return wn.ADV
    elif tag.startswith('V'):
        return wn.VERB
    return 

from nltk.stem import WordNetLemmatizer
from nltk.corpus import sentiwordnet as swn
from nltk import sent_tokenize, word_tokenize, pos_tag

def swn_polarity(text):
    # 감성 지수 초기화 
    sentiment = 0.0
    tokens_count = 0
    
    lemmatizer = WordNetLemmatizer()
    raw_sentences = sent_tokenize(text)
    # 분해된 문장별로 단어 토큰 -> 품사 태깅 후에 SentiSynset 생성 -> 감성 지수 합산 
    for raw_sentence in raw_sentences:
        # NTLK 기반의 품사 태깅 문장 추출  
        tagged_sentence = pos_tag(word_tokenize(raw_sentence))
        for word , tag in tagged_sentence:
            
            # WordNet 기반 품사 태깅과 어근 추출
            wn_tag = penn_to_wn(tag)
            if wn_tag not in (wn.NOUN , wn.ADJ, wn.ADV):
                continue                   
            lemma = lemmatizer.lemmatize(word, pos=wn_tag)
            if not lemma:
                continue
            # 어근을 추출한 단어와 WordNet 기반 품사 태깅을 입력해 Synset 객체를 생성. 
            synsets = wn.synsets(lemma , pos=wn_tag)
            if not synsets:
                continue
            # sentiwordnet의 감성 단어 분석으로 감성 synset 추출
            # 모든 단어에 대해 긍정 감성 지수는 +로 부정 감성 지수는 -로 합산해 감성 지수 계산. 
            synset = synsets[0]
            swn_synset = swn.senti_synset(synset.name())
            sentiment += (swn_synset.pos_score() - swn_synset.neg_score())           
            tokens_count += 1
    
    if not tokens_count:
        return 0
    
    # 총 score가 0 이상일 경우 긍정(Positive) 1, 그렇지 않을 경우 부정(Negative) 0 반환
    if sentiment >= 0 :
        return 1
    
    return 0

review_df['preds'] = review_df['review'].apply( lambda x : swn_polarity(x) )
y_target = review_df['sentiment'].values
preds = review_df['preds'].values

from sklearn.metrics import accuracy_score, confusion_matrix, precision_score 
from sklearn.metrics import recall_score, f1_score, roc_auc_score
import numpy as np

print(confusion_matrix( y_target, preds))
print("정확도:", np.round(accuracy_score(y_target , preds), 4))
print("정밀도:", np.round(precision_score(y_target , preds),4))
print("재현율:", np.round(recall_score(y_target, preds), 4))
```

#### VADER 이용한 감성 분석
- NLTK 서브 모듈 이용 : from nltk.sentiment.vader import SentimentIntensityAnalyzer
- 별도 모듈 이용 
    - 설치 : pip install vaderSentiment
    - import : from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer 

